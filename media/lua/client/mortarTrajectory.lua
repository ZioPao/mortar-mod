--[[⠀
----------------------------------------------------------------------------------------------------------------------------⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                       ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣰⣦⣀⣀⠀⠠⠄⠄⠠⠀⠀⢀⣠⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⡿⢿⣦⠀⠀⠀⠀⠀⠀⠀⢀⡷⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⣩⡿⠋⠙⠉⢩⡿⠟⠀⠀⠀⠀⠀⠀⢀⣶⣾⠟⠋⠛⣿⣷⡄⠀⠀⠀⠀⠀⣴⣿⠂⠀⠀⣼⡿⠀⠀⠀⠀⠀⠀⢀⣠⡴⠶⣤⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠦⠤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡿⠋⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⢠⡇⠀⠀⠀⢠⣾⠋⠀⠀⠀⠀⣸⠀⠀⠀⠀⠀⠀⠀⢠⣿⠋⠀⠀⠀⠀⠛⠛⠁⠀⠀⠀⢀⣾⣿⠏⠀⠀⢀⡿⠃⠀⠀⠀⠀⠀⠶⠋⠁⢀⣰⠟⠀⠀⠀⠀⠀⠀⠀⣹⣿⠀⠀⠀⠀⣨⣿⠇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣾⡟⢀⣠⣤⣴⣶⠆⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⣾⠀⠀⠀⣰⣿⠃⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀⠀⠀⢀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⠋⠀⠀⢀⡾⠁⠀⠀⠀⠀⠀⠀⠀⣠⣶⣯⣅⡀⠀⠀⠀⠀⠀⠀⠀⣿⡇⢀⣠⠴⠞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣸⡟⠀⠛⠉⣠⣾⠃⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⢿⣤⡴⢺⢻⠃⠀⠀⠀⠀⠀⢸⡿⠁⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⢀⣤⠀⠀⠀⠀⠀⢀⣿⣇⡤⠤⢤⣾⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⡆⠀⠀⠀⠀⠀⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⠃⠀⠀⢀⣼⠇⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢂⠇⠀⠀⠀⠀⠀⠀⣾⡅⠀⠀⠀⠀⠀⠀⠀⢸⣧⡀⠀⠀⣼⠇⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠐⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⢰⡏⠘⣦⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⢧⣤⡶⠟⢻⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⠏⠀⠀⠀⠀⠀⠀⢰⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⡾⠋⠀⠀⠀⠀⠀⠀⢸⡟⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠞⠁⠀⠀⠀⠀⠀⠀⠁⠀⠈⠙⠂⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⣿⣤⠶⠒⠒⠁⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

----------------------------------------------------------------------------------------------------------------------------
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
Please contact me if you need to hire someone to do mods or other design related tasks
https://steamcommunity.com/id/glytch3r/myworkshopfiles/
https://www.glytch3r.com
https://ko-fi.com/glytch3r
Discord: Glytch3r#2892

----------------------------------------------------------------------------------------------------------------------------
--]] Mortar = {}

Mortar.directions = {
    ["N"] = {0, -1},
    ["NE"] = {math.sqrt(2) / 2, -math.sqrt(2) / 2},
    ["E"] = {1, 0},
    ["SE"] = {math.sqrt(2) / 2, math.sqrt(2) / 2},
    ["S"] = {0, 1},
    ["SW"] = {-math.sqrt(2) / 2, math.sqrt(2) / 2},
    ["W"] = {-1, 0},
    ["NW"] = {-math.sqrt(2) / 2, -math.sqrt(2) / 2}
}
Mortar.distMin = 4
Mortar.distMax = 12
Mortar.distSteps = 2
Mortar.rad = 5
function Mortar.init()
    local pl = getPlayer()
    if not pl:getModData()['mortarDistance'] then
        pl:getModData()['mortarDistance'] = 8
    end
end
Events.OnGameStart.Add(Mortar.init)

function Mortar.debris(square)
    local dug = IsoObject.new(square, "mortar_" .. ZombRand(64), "", false)
    square:AddTileObject(dug)
    if isClient() then
        dug:transmitCompleteItemToServer();
    end
    ISInventoryPage.renderDirty = true;
end

function Mortar.roll(chance)
    local roll = ZombRand(1, 101);
    if roll <= chance then
        return true
    end
end

function testBoom(pl, bommX, bommY, bommZ, Xtype)
    local args = {
        x = bommX,
        y = bommY,
        z = bommZ
    }
    sendClientCommand(pl, 'object', Xtype, args)
    -- getSoundManager():PlayWorldSound("explode",  trajectory, 0, Mortar.distMax*2, 1.0, false);
end
function Mortar.groundZero(bommX, bommY, bommZ, radius)
    local cell = getCell()
    local playerObj = getSpecificPlayer(0)
    playerObj:startMuzzleFlash()
    for x = bommX - radius, bommX + radius + 1 do
        for y = bommY - radius, bommY + radius + 1 do
            if IsoUtils.DistanceTo(bommX, bommY, x + 0.5, y + 0.5) <= radius then
                local sq = cell:getGridSquare(x, y, bommZ)
                 local Xtype = 'addFireOnSquare'
                if Mortar.roll(20) then
                    Xtype = 'addSmokeOnSquare'
                end
                if Mortar.roll(60) then
                    local args = {
                        x = x,
                        y = y,
                        z = bommZ
                    }
                    sendClientCommand(playerObj, 'object', Xtype, args)
                end

                chance = 40
                if Mortar.roll(chance) then
                    Mortar.debris(sq)
                end
            end
        end
    end
end

function Mortar.fire(rad, dist)
    local pl = getPlayer()
    local nx = Mortar.directions[tostring(pl:getDir())][1];
    local ny = Mortar.directions[tostring(pl:getDir())][2]
    local bommX = math.floor(pl:getX() + (nx * dist))
    local bommY = math.floor(pl:getY() + (ny * dist))
    local bommZ = pl:getZ()
    -- TODO add a checker and setter for z trajectory based on the highest floor available
    local trajectory = getCell():getGridSquare(bommX, bommY, bommZ)
    local Xtype = 'addExplosionOnSquare'
    local finalRad = ZombRand(3, rad)
    -- Mortar.groundZero(bommX,bommY,bommZ,rad,Xtype)
    Mortar.groundZero(bommX, bommY, bommZ, finalRad)
    -- local args = { x = bommX, y = bommY, z = bommZ }
    -- sendClientCommand(pl, 'object', 'addExplosionOnSquare', args)
    -- sendClientCommand(pl, 'object', 'addFireOnSquare', args)
    -- getSoundManager():PlayWorldSound("explode",  trajectory, 0, Mortar.distMax*2, 1.0, false);
end

--[[ 
--local Xtype = 'addFireOnSquare'
local Xtype = 'addExplosionOnSquare'
local pl = getPlayer() 
testBoom(pl, 11964,6912,0,Xtype)
--local teleportto = {12329,6755,0}
local teleportto={11964,6912,0}
SendCommandToServer(tostring("/teleportto \"".. teleportto[1]..','..teleportto[2]..','..teleportto[3]  .."\" " .. " \""))
 ]]

-- sendClientCommand(pl, 'object', 'addExplosionOnSquare', args)
-- sendClientCommand(pl, 'object', 'addFireOnSquare', args)
function Mortar.keys(key)
    local pl = getPlayer()
    local dist = pl:getModData()['mortarDistance'] or 8
    if not pl then
        return
    end
    if (key == 83) then -- num del
        -- Mortar.init()
        Mortar.fire(10, dist)
        return key
    end
    if (key == 211) then -- DEL
        local teleportto = {12329, 6755, 0}
        SendCommandToServer(tostring(
            "/teleportto \"" .. teleportto[1] .. ',' .. teleportto[2] .. ',' .. teleportto[3] .. "\" " .. " \""))
        return key
    end

    if (key == 79) then -- num1
        -- reduce distance
        local pl = getPlayer()
        local dist = pl:getModData()['mortarDistance']
        if dist > Mortar.distMin then
            dist = dist - Mortar.distSteps
        end
        pl:Say(tostring(dist));
        print(dist)
        return key
    end

    if (key == 80) then -- num2
        local pl = getPlayer()
        local dist = pl:getModData()['mortarDistance']
        if dist < Mortar.distMax then
            dist = dist - Mortar.distSteps
        end
        pl:Say(tostring(dist));
        print(dist)
        return key
    end

    if (key == 81) then -- num3
        pl:Say(tostring(dist))
        print('-------------')
        print('dist: ' .. dist)
        print('distMin: ' .. Mortar.distMin)
        print('distMax: ' .. Mortar.distMax)
        print('distSteps: ' .. Mortar.distSteps)
        print('-------------')
        return key
    end
    --[[     print(getPlayer():getSquare():getAdjacentSquare(getPlayer():getDir()):getX())
    print(getPlayer():getSquare():getAdjacentSquare(getPlayer():getDir()):getY())
    print(getPlayer():getSquare():getX())
    print(getPlayer():getSquare():getY()) ]]

end
Events.OnKeyPressed.Remove(Mortar.keys);
Events.OnKeyPressed.Add(Mortar.keys);

--[[ 
function ISWorldObjectContextMenu.getSquaresInRadius(worldX, worldY, worldZ, radius, doneSquares, squares)
	local minX = math.floor(worldX - radius)
	local maxX = math.ceil(worldX + radius)
	local minY = math.floor(worldY - radius)
	local maxY = math.ceil(worldY + radius)
	for y = minY,maxY do
		for x = minX,maxX do
			local square = getCell():getGridSquare(x, y, worldZ)
			if square and not doneSquares[square] then
				doneSquares[square] = true
				table.insert(squares, square)
			end
		end
	end
end

local x,y,z = getPlayer():getX(), getPlayer():getY(), getPlayer():getZ() 
getGameTime():getModData()['MortarHit'] ='wew'
print(getGameTime():getModData()['MortarHit'])
getGameTime():getModData()[
]]
