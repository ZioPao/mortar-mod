--[[⠀
----------------------------------------------------------------------------------------------------------------------------⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                       ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣰⣦⣀⣀⠀⠠⠄⠄⠠⠀⠀⢀⣠⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⡿⢿⣦⠀⠀⠀⠀⠀⠀⠀⢀⡷⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⣩⡿⠋⠙⠉⢩⡿⠟⠀⠀⠀⠀⠀⠀⢀⣶⣾⠟⠋⠛⣿⣷⡄⠀⠀⠀⠀⠀⣴⣿⠂⠀⠀⣼⡿⠀⠀⠀⠀⠀⠀⢀⣠⡴⠶⣤⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠦⠤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡿⠋⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⢠⡇⠀⠀⠀⢠⣾⠋⠀⠀⠀⠀⣸⠀⠀⠀⠀⠀⠀⠀⢠⣿⠋⠀⠀⠀⠀⠛⠛⠁⠀⠀⠀⢀⣾⣿⠏⠀⠀⢀⡿⠃⠀⠀⠀⠀⠀⠶⠋⠁⢀⣰⠟⠀⠀⠀⠀⠀⠀⠀⣹⣿⠀⠀⠀⠀⣨⣿⠇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣾⡟⢀⣠⣤⣴⣶⠆⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⣾⠀⠀⠀⣰⣿⠃⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀⠀⠀⢀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⠋⠀⠀⢀⡾⠁⠀⠀⠀⠀⠀⠀⠀⣠⣶⣯⣅⡀⠀⠀⠀⠀⠀⠀⠀⣿⡇⢀⣠⠴⠞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣸⡟⠀⠛⠉⣠⣾⠃⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⢿⣤⡴⢺⢻⠃⠀⠀⠀⠀⠀⢸⡿⠁⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⢀⣤⠀⠀⠀⠀⠀⢀⣿⣇⡤⠤⢤⣾⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⡆⠀⠀⠀⠀⠀⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⠃⠀⠀⢀⣼⠇⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢂⠇⠀⠀⠀⠀⠀⠀⣾⡅⠀⠀⠀⠀⠀⠀⠀⢸⣧⡀⠀⠀⣼⠇⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠐⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⢰⡏⠘⣦⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⢧⣤⡶⠟⢻⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⠏⠀⠀⠀⠀⠀⠀⢰⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⡾⠋⠀⠀⠀⠀⠀⠀⢸⡟⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠞⠁⠀⠀⠀⠀⠀⠀⠁⠀⠈⠙⠂⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⣿⣤⠶⠒⠒⠁⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

----------------------------------------------------------------------------------------------------------------------------
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
Please contact me if you need to hire someone to do mods or other design related tasks
https://steamcommunity.com/id/glytch3r/myworkshopfiles/
https://www.glytch3r.com
https://ko-fi.com/glytch3r
Discord: Glytch3r#2892

Join Glytch3r Mods Discord Server:
https://discord.gg/2skchrKrDv 
----------------------------------------------------------------------------------------------------------------------------
--]]

-- TODO Add Mortar spawning logic
-- TODO Add recipes?
-- TODO Add check for higher z



Mortar = {}
Mortar.directions = {
    ["N"] = {0, -1},
    ["NE"] = {math.sqrt(2) / 2, -math.sqrt(2) / 2},
    ["E"] = {1, 0},
    ["SE"] = {math.sqrt(2) / 2, math.sqrt(2) / 2},
    ["S"] = {0, 1},
    ["SW"] = {-math.sqrt(2) / 2, math.sqrt(2) / 2},
    ["W"] = {-1, 0},
    ["NW"] = {-math.sqrt(2) / 2, -math.sqrt(2) / 2}
}
Mortar.distMin = 4
Mortar.distMax = 12
Mortar.distSteps = 2
Mortar.rad = SandboxVars.Mortar.Radius or 8





function Mortar.init()

    print("Mortar: Initializing")


    local pl = getPlayer()
    if not pl:getModData()['mortarDistance'] then
        pl:getModData()['mortarDistance'] = SandboxVars.Mortar.Radius or 8
    end


end
Events.OnGameStart.Add(Mortar.init)


Mortar.SpawnDebris = function(square)
    -- the tile starts at 0 and ends 64 -8 (8  mortar tiles)
    local dug = IsoObject.new(square, "mortar_" .. ZombRand(63)-8, "", false) 
    square:AddTileObject(dug)
    if isClient() then
        dug:transmitCompleteItemToServer()
    end
    --ISInventoryPage.renderDirty = true
end
Mortar.roll = function(chance)
    local roll = ZombRand(1, 101);
    if roll <= chance then
        return true
    end
end
Mortar.GenGroundZero = function(operator, spotter, bommX, bommY, bommZ, radius)
    local cell = getWorld():getCell()      -- We need to get the correct cell, not this one
    operator:startMuzzleFlash()

    print("_____________________________")
    print(bommX)
    print(radius)

    print(bommY)
    print(radius)

    print(bommZ)
    print(radius)



    for x = bommX - radius, bommX + radius + 1 do
        for y = bommY - radius, bommY + radius + 1 do
            if IsoUtils.DistanceTo(bommX, bommY, x + 0.5, y + 0.5) <= radius then
                local sq = cell:getGridSquare(x, y, bommZ)
                local Xtype = 'addFireOnSquare'
                if Mortar.roll(20) then
                    Xtype = 'addSmokeOnSquare'
                end
                if sq:Is(IsoFlagType.burning) then 
                    sq:getModData()['mortarHit'] = true

                    -- TODO OnTIck is overkill imo -- i dont know what to do
                    Events.OnTick.Add(function() 
                        if sq:getModData()['mortarHit'] and not sq:Is(IsoFlagType.burning)  then 
                            sq:getModData()['mortarHit'] = nil
                        end
                    end)

                end
                if Mortar.roll(60) then
                    local args = {
                        x = x,
                        y = y,
                        z = bommZ
                    }
                    sendClientCommand(spotter, 'object', Xtype, args)
                end
                chance = 40
                if Mortar.roll(chance) then
                    Mortar.SpawnDebris(sq)
                end

                -- Kill whatever thing is in the square
                local entities = sq:getMovingObjects()

                if entities then
                    for i = entities:size(), 1, -1 do
                        local entity = entities:get(i - 1)
                        if instanceof(entity, "IsoZombie") or instanceof(entity, "IsoPlayer") then
                            if not entity:isGodMod() then
                                entity:Kill(entity)
                            end
                        end
                    end
                end
            end
        end
    end
end
Mortar.ExecuteFire = function(operator, spotter, rad, dist)






    local nx = Mortar.directions[tostring(spotter:getDir())][1]
    local ny = Mortar.directions[tostring(spotter:getDir())][2]

    -- Since we want to "simulate" this stuff and we can't really start from the operator with a system
    -- like this, we'll have to use the spotter as a base...
    local bommX = math.floor(spotter:getX() + (nx * dist))
    local bommY = math.floor(spotter:getY() + (ny * dist))
    local bommZ = operator:getZ()
    -- TODO add a checker and setter for z trajectory based on the highest floor available
    local trajectory = getCell():getGridSquare(bommX, bommY, bommZ)
    local Xtype = 'addExplosionOnSquare'
    local finalRad = ZombRand(3, rad)

    print(bommX)
    print(bommY)
    print(bommZ)
    print(finalRad)

    -- TODO This could break if the spotter moves away from the cell. So let's consider that
    if Mortar.direct_coordinates ~= nil then
        local test = Mortar.direct_coordinates
        Mortar.GenGroundZero(operator, spotter, Mortar.direct_coordinates[1], Mortar.direct_coordinates[2], 0, finalRad)
        Mortar.direct_coordinates = nil     -- Reset them?
    else
        Mortar.GenGroundZero(operator, spotter, bommX, bommY, bommZ, finalRad)

    end

end


Mortar.StartFiring = function(operator, spotter, rad, dist)
    print("Mortar: Trying to fire")
    -- SP or when there's no need for a spotter
    if not isServer() and not isClient() or not SandboxVars.Mortar.NecessarySpotter then -- i change the default to false
        print("SP or no Necessary Spotter")
        Mortar.spotter = pl
        Mortar.ExecuteFire(operator, spotter, rad, dist)
    else
        if spotter == nil then
            print("No spotter")
            operator:Say("I don't have a spotter right now")
            return
        end

        print("Checking again for walkie talkie")
        if Mortar.CheckPlayerForWalkieTalkie(spotter) then
            -- TODO Add a check for visibility -- probably a sandbox will do
            Mortar.ExecuteFire(operator, spotter, rad, dist)
        else
            print("No walkie talkie on spotter")
            operator:Say("My spotter has no Walkie Talkie on their hand")
        end

    end


end

-----------------------------------------------------------


-- Disassemble and returns the item to the player inventory
Mortar.Disassemble = function()

end


Mortar.CheckBomberDistanceFromMortar = function()


    if Mortar.bomber == nil then
        print("Mortar: Can't find bomber anymore, exiting update")
        Events.OnTick.Remove(Mortar.CheckBomberDistanceFromMortar)
    end

    -- TODO We're not considering height, should be fine though.
    local pl_x = Mortar.bomber:getX()
    local pl_y = Mortar.bomber:getY()

    local mort_x = Mortar.current_mortar:getX()
    local mort_y = Mortar.current_mortar:getY()

    local max_distance_from_mortar = 1.5

    if MortarGetDistance2D(pl_x, pl_y, mort_x, mort_y) > max_distance_from_mortar then
        MortarUI.close()        -- This also unset the bomber, kinda janky
        Events.OnTick.Remove(Mortar.CheckBomberDistanceFromMortar)

    end



end


Mortar.SetBomber = function(player)

    local pl = getPlayerByOnlineID(player)

    -- TODO Mostly for test, delete this when releasing this
    if pl == nil then
        pl = getPlayer()
    end


    Mortar.bomber = pl
    MortarUI.OnOpenPanel()

    print("Mortar: added bomber, starting loop")
    Events.OnTick.Add(Mortar.CheckBomberDistanceFromMortar)


    --pl:setIgnoreMovement(true)      -- TODO this limits even aiming. Too strict

    -- TODO Should update player rotation based on the position of the spotter
end


Mortar.GetBomber = function()
    return Mortar.bomber
end

Mortar.UnsetBomber = function()
    Mortar.bomber = nil

end


Mortar.SetCurrentMortar = function(obj)
    Mortar.current_mortar = obj
end