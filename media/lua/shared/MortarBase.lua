--[[⠀
----------------------------------------------------------------------------------------------------------------------------⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                       ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣰⣦⣀⣀⠀⠠⠄⠄⠠⠀⠀⢀⣠⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⡿⢿⣦⠀⠀⠀⠀⠀⠀⠀⢀⡷⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⣩⡿⠋⠙⠉⢩⡿⠟⠀⠀⠀⠀⠀⠀⢀⣶⣾⠟⠋⠛⣿⣷⡄⠀⠀⠀⠀⠀⣴⣿⠂⠀⠀⣼⡿⠀⠀⠀⠀⠀⠀⢀⣠⡴⠶⣤⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠦⠤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡿⠋⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⢠⡇⠀⠀⠀⢠⣾⠋⠀⠀⠀⠀⣸⠀⠀⠀⠀⠀⠀⠀⢠⣿⠋⠀⠀⠀⠀⠛⠛⠁⠀⠀⠀⢀⣾⣿⠏⠀⠀⢀⡿⠃⠀⠀⠀⠀⠀⠶⠋⠁⢀⣰⠟⠀⠀⠀⠀⠀⠀⠀⣹⣿⠀⠀⠀⠀⣨⣿⠇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣾⡟⢀⣠⣤⣴⣶⠆⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⣾⠀⠀⠀⣰⣿⠃⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀⠀⠀⢀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⠋⠀⠀⢀⡾⠁⠀⠀⠀⠀⠀⠀⠀⣠⣶⣯⣅⡀⠀⠀⠀⠀⠀⠀⠀⣿⡇⢀⣠⠴⠞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣸⡟⠀⠛⠉⣠⣾⠃⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⢿⣤⡴⢺⢻⠃⠀⠀⠀⠀⠀⢸⡿⠁⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⢀⣤⠀⠀⠀⠀⠀⢀⣿⣇⡤⠤⢤⣾⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⡆⠀⠀⠀⠀⠀⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⠃⠀⠀⢀⣼⠇⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢂⠇⠀⠀⠀⠀⠀⠀⣾⡅⠀⠀⠀⠀⠀⠀⠀⢸⣧⡀⠀⠀⣼⠇⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠐⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⢰⡏⠘⣦⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⢧⣤⡶⠟⢻⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⠏⠀⠀⠀⠀⠀⠀⢰⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⡾⠋⠀⠀⠀⠀⠀⠀⢸⡟⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠞⠁⠀⠀⠀⠀⠀⠀⠁⠀⠈⠙⠂⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⣿⣤⠶⠒⠒⠁⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

----------------------------------------------------------------------------------------------------------------------------
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
Please contact me if you need to hire someone to do mods or other design related tasks
https://steamcommunity.com/id/glytch3r/myworkshopfiles/
https://www.glytch3r.com
https://ko-fi.com/glytch3r
Discord: Glytch3r#2892

Join Glytch3r Mods Discord Server:
https://discord.gg/2skchrKrDv 
----------------------------------------------------------------------------------------------------------------------------
--]]


--[[ TODO Right now we're not making a new instance for this object. This means that only a single mortar would work
        correctly on the whole server. We need to have something like Mortar.instantiate() where we generate a new
        mortar object to assign the mortar tile\item
    --]]

require "MortarCheckAxisZ"

-- Init Mortar table
--------------------------------------------------------------
Mortar = {}

local function updateCheckBomberDistance()

    Mortar:checkBomberDistanceFromMortar()

end


-------------------------------------------------------------
-- Getters\Setters
------------------------------------------------------------

--- Set the current bomber and notify the spotter
--- @param player IsoPlayer
function Mortar:setBomber(player_id)

    -- TODO We shouldn't even get in here without a spotter.

    if self.spotter == nil then
        print("Mortar: no spotter, can't set bomber")
        return
    end


    local bomber = getPlayerByOnlineID(player_id)

    -- TODO Mostly for test, delete this when releasing this
    if bomber == nil then
        bomber = getPlayer()
    end

    self.bomber = bomber
    MortarUI.onOpenPanel()


    sendClientCommand(bomber, "Mortar", "sendMortarToSpotter", {bomber_id = bomber:getOnlineID(), spotter_id = self.spotter:getOnlineID()})




    -- Send a command to the spotter so we he can send us back their coordinates
    sendClientCommand(bomber, "Mortar", "sendMortarToSpotter", {spotter_id = Mortar:getSpotter():getOnlineID(), mortar=Mortar:getInstance()
})


    print("Mortar: added bomber, starting loop")
    Events.OnTick.Add(updateCheckBomberDistance)

    -- TODO Should update player rotation based on the position of the spotter
end

--- Get the current bomber or nil
--- @return IsoPlayer
function Mortar:getBomber()
    return self.bomber
end

--- Basically a workaround
function Mortar:forceSetBomber(player_id)

    self.bomber = getPlayerByOnlineID(player_id)


end


---Unset the current bomber
function Mortar:unsetBomber()
    self.bomber = nil

end

function Mortar:getSpotter()
    return self.spotter

end

---Set the currently used mortar
---@param obj IsoObject
function Mortar:setCurrentMortar(obj)
    self.current_mortar = obj
end

function Mortar:getCurrentMortar()


    return self.current_mortar
    

end


function Mortar:isAvailable()

    if self.current_mortar and self.bomber then
        return false
    else
        return true
    end

end

-------------------------------------------------------------
-- Shooting logic
------------------------------------------------------------


function Mortar:setDirectCoordinates(x, y)

    self.direct_coordinates = {x,y}

end



---Spawn debris in the chosen square
---@param square IsoSquare
Mortar.spawnDebris = function(square)
    -- the tile starts at 0 and ends 64 -8 (8  mortar tiles)
    local dug = IsoObject.new(square, "mortar_" .. ZombRand(63)-8, "", false) 
    square:AddTileObject(dug)
    if isClient() then
        dug:transmitCompleteItemToServer()
    end
    ISInventoryPage.renderDirty = true
end


--- Generate explosion and\or debris in the zone
---@param operator IsoPlayer
---@param spotter IsoPlayer
---@param bommX number
---@param bommY number
---@param bommZ number
---@param radius number
function Mortar:genGroundZero(bommX, bommY, bommZ, radius)
    local cell = getWorld():getCell()      -- We need to get the correct cell, not this one
    self.bomber:startMuzzleFlash()         -- TODO we need to sync this, it will happen only on the spotter client right now

    for x = bommX - radius, bommX + radius + 1 do
        for y = bommY - radius, bommY + radius + 1 do
            if IsoUtils.DistanceTo(bommX, bommY, x + 0.5, y + 0.5) <= radius then
                local sq = cell:getGridSquare(x, y, bommZ)
                local Xtype = 'addFireOnSquare'
                if MortarCommonFunctions.roll(20) then
                    Xtype = 'addSmokeOnSquare'
                end
                if sq:Is(IsoFlagType.burning) then 
                    sq:getModData()['mortarHit'] = true

                    -- TODO OnTIck is overkill imo -- i dont know what to do and this might not event work
                    Events.OnTick.Add(function() 
                        if sq:getModData()['mortarHit'] and not sq:Is(IsoFlagType.burning)  then 
                            sq:getModData()['mortarHit'] = nil
                        end
                    end)

                end
                if MortarCommonFunctions.roll(60) then
                    local args = {
                        x = x,
                        y = y,
                        z = bommZ
                    }
                    sendClientCommand(self.spotter, 'object', Xtype, args)
                end

                local chance = 40
                if MortarCommonFunctions.roll(chance) then
                    Mortar.spawnDebris(sq)
                end

                -- Kill whatever thing is in the square
                local entities = sq:getMovingObjects()

                if entities then
                    for i = entities:size(), 1, -1 do
                        local entity = entities:get(i - 1)
                        if instanceof(entity, "IsoZombie") or instanceof(entity, "IsoPlayer") then
                            if not entity:isGodMod() then
                                entity:Kill(entity)
                            end
                        end
                    end
                end
            end
        end
    end
end

---Manages the actual mortar shot explosion
---@param operator IsoPlayer
---@param spotter IsoPlayer
---@param rad number
---@param dist number
function Mortar:executeFire()

    local nx = MortarCommonVars.directions[tostring(self.spotter:getDir())][1]
    local ny = MortarCommonVars.directions[tostring(self.spotter:getDir())][2]

    -- Since we want to "simulate" this stuff and we can't really start from the operator with a system
    -- like this, we'll have to use the spotter as a base...
    local bommX = math.floor(self.spotter:getX() + (nx * dist))
    local bommY = math.floor(self.spotter:getY() + (ny * dist))
    local bommZ = MortarGetHighestZ(bommX,bommY)  --operator:getZ()     -- TODO Move this here
   
   
    -- TODO add a checker and setter for z trajectory based on the highest floor available
    local trajectory = getCell():getGridSquare(bommX, bommY, bommZ)
    local Xtype = 'addExplosionOnSquare'
    local finalRad = ZombRand(3, rad)

    print(bommX)
    print(bommY)
    print(bommZ)
    print(finalRad)

    -- TODO This could break if the spotter moves away from the cell. So let's consider that
    if self.direct_coordinates ~= nil then
        self:genGroundZero(self.direct_coordinates[1], self.direct_coordinates[2], 0, finalRad)
    else
        self:genGroundZero(bommX, bommY, bommZ, finalRad)

    end

end

---Setup the mortar to start fire or not in case something is missing
function Mortar:startFiring()
    print("Mortar: Trying to fire")
    if self.spotter == nil then
        print("No spotter")
        self.bomber:Say("I don't have a spotter right now")
        return
    end

    print("Checking again if spotter is valid")
    if Mortar.isSpotterValid(self.spotter) then
        -- TODO Add a check for visibility -- probably a sandbox var will do
        Mortar.executeFire(operator, spotter, rad, dist)
    else
        if spotter == nil then
            print("No spotter")
            operator:Say("I don't have a spotter right now")
            return
        end

        print("Checking again for walkie talkie")
        if Mortar.checkRadio(spotter) then
            -- TODO Add a check for visibility -- probably a sandbox var will do
            Mortar.executeFire(operator, spotter, rad, dist)
        else
            print("No walkie talkie on spotter")
            operator:Say("My spotter has no Walkie Talkie on their hand")       -- TODO This is gonna appear on the spotter client!!! Doesn't make any sense
        end

    end




end





-------------------------------------------------------------
-- Spotter functions
------------------------------------------------------------

---Set the current spotter
function Mortar:setSpotter(player)
    -- TODO this implies that there is only a single Mortar object on the whole server. We meed to add an init for the mortar to instance it
    print("Mortar: Setting spotter")

    self.spotter = player
    -- FIXME Pao: I don't think this will work since we're in shared, so not sure which player would be fetched.

    -- This Event should be added when we're setting a spotter
    Events.OnPlayerDeath.Add(function(pl_obj)

        if self.spotter then
            if self.spotter == pl_obj then
                self:unsetSpotter()
            end
        end

        if self.bomber then
            if self.bomber == pl_obj then
                self:unsetBomber()
            end
        end



    end)
end

function Mortar:unsetSpotter()
    self.spotter = nil
end




-------------------------------------------------------------
-- Various static checks functions
------------------------------------------------------------

Mortar.isBomberValid = function(player)

    if player:isDriving() or player:getVehicle() then return false end
    if not player:isOutside() then return false end
    if player:HasTrait('HardOfHearing') or player:HasTrait('Deaf') then return false end
    if (player:isRunning() or player:isSprinting()) then return false end
    if not player:isAsleep() then return true end
    --TODO isHasFog --check if theres fog find the syntax  maybe  DayForecast() ? 

end


---Check if the player has a working radio
---@param player any
Mortar.checkRadio = function(player)
    -- Pao: Binoculars shouldn't be necessary, only a radio. Binos are just an added bonus, imo
    -- Radios are set with Category = Item... So we have to fetch them before doing anything else

    -- TODO This can't be used from the bomber client, we can't access the radio from here.
    local inv = player:getInventory()
    local items = inv:getItems()

    local radio
    for i = 0, items:size() - 1 do
        local item = items:get(i)
        local item_full_type = item:getFullType()

        -- not sure why instanceof didn't work, but this should be fine
        if luautils.stringStarts(item_full_type, "Radio.") then
            radio = item
            break
        end
    end

    -- Another problem, to check if a radio is turned on we need to get getDeviceData(), not isActivated
    if radio then
        local device_data = radio:getDeviceData()
        if device_data:getIsTurnedOn() then
            print("Mortar: Radio is ready to go for the spotter")
            return true
        end
    end
    return false
end


Mortar.isSpotterValid = function(player)


    -- TODO WE can't check for radio here, from the bomber client. We should add a server command to check it

    if player:isDriving() or player:getVehicle() then return false end
    if player:HasTrait('ShortSighted')  then return false end
    --if pl:isAiming() or pl:isSneaking() then return false end
    if (player:isRunning() or player:isSprinting()) then return false end
    if not player:isAsleep() then return true end

end


-------------------------------------------------------------
-- Various functions
------------------------------------------------------------

-- Disassemble and returns the item to the player inventory
Mortar.disassemble = function()
    -- TODO Implement it?
end

-- Check the distance between bomber and mortar tile
function Mortar:checkBomberDistanceFromMortar()
    if self.bomber == nil then
        print("Mortar: Can't find bomber anymore, exiting update")
        Events.OnTick.Remove(updateCheckBomberDistance)
        MortarUI:close()        -- This also unset the bomber, kinda janky
        return
    end

    -- TODO We're not considering height, should be fine though.
    local pl_x = self.bomber:getX()
    local pl_y = self.bomber:getY()


    local mort_x = self.current_mortar:getX()
    local mort_y = self.current_mortar:getY()

    if MortarCommonFunctions.getDistance2D(pl_x, pl_y, mort_x, mort_y) > MortarCommonVars.distSteps then
        MortarUI:close()        -- This also unset the bomber, kinda janky
        Events.OnTick.Remove(updateCheckBomberDistance)

    end
end



-------------------------------------------------------

function Mortar:new()

    -- TODO Let this run when we spawn a mortar item\tile
    print("Mortar: Instancing new one")
    local instance = {}

    setmetatable(instance, self)

    self.__index = self
    instance.bomber = nil
    instance.spotter = nil
    instance.current_mortar = nil        -- Should be the item\tile that's linked to this instance

    instance.direct_coordinates = nil

    Mortar.instance = instance

    return instance



end

function Mortar:getInstance()

    return Mortar.instance

end
function Mortar:setInstance(mortar_instance)

    local new_instance = self:new()

    new_instance.bomber = mortar_instance:getBomber()
    new_instance.spotter = mortar_instance:getSpotter()
    new_instance.current_mortar = mortar_instance:getCurrentMortar()
    new_instance.direct_coordinates = nil       -- TODO Re add

    return new_instance

end


function Mortar:testPrint()


    print(self.spotter)

end






local initMortarMod = function()
    print("Mortar Mod: Initializing")
    local pl = getPlayer()
    if not pl:getModData()['mortarDistance'] then
        pl:getModData()['mortarDistance'] = SandboxVars.Mortar.Radius or 8
    end


    Events.OnObjectAdded.Add(function(object)
        for _, v in pairs(MortarRotation.tileobj) do
            if object:getSprite() == v then
                Mortar:new(object)
                break
            end
        end
        

        -- if object:getFullType() == "Mortar.MortarWeapon" then
        --     Mortar:new(object)
        -- else
        --     print("Not mortar")
        -- end
    end)

end
Events.OnGameStart.Add(initMortarMod)



