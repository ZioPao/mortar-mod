--[[⠀
----------------------------------------------------------------------------------------------------------------------------⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                       ⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣰⣦⣀⣀⠀⠠⠄⠄⠠⠀⠀⢀⣠⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⡿⢿⣦⠀⠀⠀⠀⠀⠀⠀⢀⡷⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⣩⡿⠋⠙⠉⢩⡿⠟⠀⠀⠀⠀⠀⠀⢀⣶⣾⠟⠋⠛⣿⣷⡄⠀⠀⠀⠀⠀⣴⣿⠂⠀⠀⣼⡿⠀⠀⠀⠀⠀⠀⢀⣠⡴⠶⣤⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠦⠤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡿⠋⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⢠⡇⠀⠀⠀⢠⣾⠋⠀⠀⠀⠀⣸⠀⠀⠀⠀⠀⠀⠀⢠⣿⠋⠀⠀⠀⠀⠛⠛⠁⠀⠀⠀⢀⣾⣿⠏⠀⠀⢀⡿⠃⠀⠀⠀⠀⠀⠶⠋⠁⢀⣰⠟⠀⠀⠀⠀⠀⠀⠀⣹⣿⠀⠀⠀⠀⣨⣿⠇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣾⡟⢀⣠⣤⣴⣶⠆⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⣾⠀⠀⠀⣰⣿⠃⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀⠀⠀⢀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⠋⠀⠀⢀⡾⠁⠀⠀⠀⠀⠀⠀⠀⣠⣶⣯⣅⡀⠀⠀⠀⠀⠀⠀⠀⣿⡇⢀⣠⠴⠞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣸⡟⠀⠛⠉⣠⣾⠃⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⢿⣤⡴⢺⢻⠃⠀⠀⠀⠀⠀⢸⡿⠁⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⢀⣤⠀⠀⠀⠀⠀⢀⣿⣇⡤⠤⢤⣾⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⡆⠀⠀⠀⠀⠀⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⠃⠀⠀⢀⣼⠇⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢂⠇⠀⠀⠀⠀⠀⠀⣾⡅⠀⠀⠀⠀⠀⠀⠀⢸⣧⡀⠀⠀⣼⠇⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠐⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⢰⡏⠘⣦⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⢧⣤⡶⠟⢻⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⠏⠀⠀⠀⠀⠀⠀⢰⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣶⡾⠋⠀⠀⠀⠀⠀⠀⢸⡟⠀⠀⠀⢰⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠞⠁⠀⠀⠀⠀⠀⠀⠁⠀⠈⠙⠂⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⠀⢀⣿⣤⠶⠒⠒⠁⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

----------------------------------------------------------------------------------------------------------------------------
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
Please contact me if you need to hire someone to do mods or other design related tasks
https://steamcommunity.com/id/glytch3r/myworkshopfiles/
https://www.glytch3r.com
https://ko-fi.com/glytch3r
Discord: Glytch3r#2892

Join Glytch3r Mods Discord Server:
https://discord.gg/2skchrKrDv 
----------------------------------------------------------------------------------------------------------------------------
--]]


--[[ TODO Right now we're not making a new instance for this object. This means that only a single mortar would work
        correctly on the whole server. We need to have something like Mortar.instantiate() where we generate a new
        mortar object to assign the mortar tile\item
    --]]

require "MortarCheckAxisZ"

-- Init Mortar table
--------------------------------------------------------------
Mortar = {}
Mortar.directions = {
    ["N"] = {0, -1},
    ["NE"] = {math.sqrt(2) / 2, -math.sqrt(2) / 2},
    ["E"] = {1, 0},
    ["SE"] = {math.sqrt(2) / 2, math.sqrt(2) / 2},
    ["S"] = {0, 1},
    ["SW"] = {-math.sqrt(2) / 2, math.sqrt(2) / 2},
    ["W"] = {-1, 0},
    ["NW"] = {-math.sqrt(2) / 2, -math.sqrt(2) / 2}
}
Mortar.distMin = 4
Mortar.distMax = 12
Mortar.distSteps = 2
Mortar.rad = SandboxVars.Mortar.Radius or 8

-------------------------------------------------------------
-- Getters\Setters
------------------------------------------------------------

--- Set the current bomber and notify the spotter
--- @param player IsoPlayer
Mortar.setBomber = function(player_id)

    -- TODO We shouldn't even get in here without a spotter.
    local pl = getPlayerByOnlineID(player_id)

    -- TODO Mostly for test, delete this when releasing this
    if pl == nil then
        pl = getPlayer()
    end


    Mortar.bomber = pl
    MortarUI.onOpenPanel()


    local temp_spotter = Mortar.spotter
    print(Mortar.spotter)
    

    -- Send a command to the spotter so we he can send us back their coordinates
    sendClientCommand(pl, "Mortar", "notifySpotter", {bomber_id = player_id, spotter_id = Mortar.spotter:getOnlineID()})




    print("Mortar: added bomber, starting loop")
    Events.OnTick.Add(Mortar.checkBomberDistanceFromMortar)


    --pl:setIgnoreMovement(true)      -- TODO this limits even aiming. Too strict

    -- TODO Should update player rotation based on the position of the spotter
end

--- Get the current bomber or nil
--- @return IsoPlayer
Mortar.getBomber = function()
    return Mortar.bomber
end

---Unset the current bomber
Mortar.unsetBomber = function()
    Mortar.bomber = nil

end

---Set the currently used mortar
---@param obj IsoObject
Mortar.setCurrentMortar = function(obj)
    Mortar.current_mortar = obj
end


-------------------------------------------------------------
-- Shooting logic
------------------------------------------------------------

---Spawn debris in the chosen square
---@param square IsoSquare
Mortar.spawnDebris = function(square)
    -- the tile starts at 0 and ends 64 -8 (8  mortar tiles)
    local dug = IsoObject.new(square, "mortar_" .. ZombRand(63)-8, "", false) 
    square:AddTileObject(dug)
    if isClient() then
        dug:transmitCompleteItemToServer()
    end
    ISInventoryPage.renderDirty = true
end


--- Generate explosion and\or debris in the zone
---@param operator IsoPlayer
---@param spotter IsoPlayer
---@param bommX number
---@param bommY number
---@param bommZ number
---@param radius number
Mortar.genGroundZero = function(operator, spotter, bommX, bommY, bommZ, radius)
    local cell = getWorld():getCell()      -- We need to get the correct cell, not this one
    operator:startMuzzleFlash()         -- TODO we need to sync this, it will happen only on the spotter client right now

    for x = bommX - radius, bommX + radius + 1 do
        for y = bommY - radius, bommY + radius + 1 do
            if IsoUtils.DistanceTo(bommX, bommY, x + 0.5, y + 0.5) <= radius then
                local sq = cell:getGridSquare(x, y, bommZ)
                local Xtype = 'addFireOnSquare'
                if MortarCommonFunctions.roll(20) then
                    Xtype = 'addSmokeOnSquare'
                end
                if sq:Is(IsoFlagType.burning) then 
                    sq:getModData()['mortarHit'] = true

                    -- TODO OnTIck is overkill imo -- i dont know what to do and this might not event work
                    Events.OnTick.Add(function() 
                        if sq:getModData()['mortarHit'] and not sq:Is(IsoFlagType.burning)  then 
                            sq:getModData()['mortarHit'] = nil
                        end
                    end)

                end
                if MortarCommonFunctions.roll(60) then
                    local args = {
                        x = x,
                        y = y,
                        z = bommZ
                    }
                    sendClientCommand(spotter, 'object', Xtype, args)
                end

                local chance = 40
                if MortarCommonFunctions.roll(chance) then
                    Mortar.spawnDebris(sq)
                end

                -- Kill whatever thing is in the square
                local entities = sq:getMovingObjects()

                if entities then
                    for i = entities:size(), 1, -1 do
                        local entity = entities:get(i - 1)
                        if instanceof(entity, "IsoZombie") or instanceof(entity, "IsoPlayer") then
                            if not entity:isGodMod() then
                                entity:Kill(entity)
                            end
                        end
                    end
                end
            end
        end
    end
end

---Manages the actual mortar shot explosion
---@param operator IsoPlayer
---@param spotter IsoPlayer
---@param rad number
---@param dist number
Mortar.executeFire = function(operator, spotter, rad, dist)

    local nx = Mortar.directions[tostring(spotter:getDir())][1]
    local ny = Mortar.directions[tostring(spotter:getDir())][2]

    -- Since we want to "simulate" this stuff and we can't really start from the operator with a system
    -- like this, we'll have to use the spotter as a base...
    local bommX = math.floor(spotter:getX() + (nx * dist))
    local bommY = math.floor(spotter:getY() + (ny * dist))
    local bommZ = MortarGetHighestZ(bommX,bommY)  --operator:getZ()
   
   
    -- TODO add a checker and setter for z trajectory based on the highest floor available
    local trajectory = getCell():getGridSquare(bommX, bommY, bommZ)
    local Xtype = 'addExplosionOnSquare'
    local finalRad = ZombRand(3, rad)

    print(bommX)
    print(bommY)
    print(bommZ)
    print(finalRad)

    -- TODO This could break if the spotter moves away from the cell. So let's consider that
    if Mortar.direct_coordinates ~= nil then
        local test = Mortar.direct_coordinates
        Mortar.genGroundZero(operator, spotter, Mortar.direct_coordinates[1], Mortar.direct_coordinates[2], 0, finalRad)
        Mortar.direct_coordinates = nil     -- Reset them?
    else
        Mortar.genGroundZero(operator, spotter, bommX, bommY, bommZ, finalRad)

    end

end

---Setup the mortar to start fire or not in case something is missing
---@param operator IsoPlayer
---@param spotter IsoPlayer
---@param rad number
---@param dist number
Mortar.startFiring = function(operator, spotter, rad, dist)
    print("Mortar: Trying to fire")
    -- SP or when there's no need for a spotter
    if not isServer() and not isClient() or not SandboxVars.Mortar.NecessarySpotter then -- i change the default to false
        print("SP or no Necessary Spotter")
        Mortar.spotter = pl
        Mortar.executeFire(operator, spotter, rad, dist)
    else
        if spotter == nil then
            print("No spotter")
            operator:Say("I don't have a spotter right now")
            return
        end

        print("Checking again for walkie talkie")
        if Mortar.checkSpotterRadio(spotter) then
            -- TODO Add a check for visibility -- probably a sandbox var will do
            Mortar.executeFire(operator, spotter, rad, dist)
        else
            print("No walkie talkie on spotter")
            operator:Say("My spotter has no Walkie Talkie on their hand")       -- TODO This is gonna appear on the spotter client!!! Doesn't make any sense
        end

    end


end





-------------------------------------------------------------
-- Spotter functions
------------------------------------------------------------

---Set the current spotter
Mortar.setSpotter = function(_, player)
    -- TODO this implies that there is only a single Mortar object on the whole server. We meed to add an init for the mortar to instance it
    print("Mortar: Setting spotter")

    Mortar.spotter = player
    -- FIXME Pao: I don't think this will work since we're in shared, so not sure which player would be fetched.

    -- This Event should be added when we're setting a spotter
    Events.OnPlayerDeath.Add(function(pl_obj)

        if Mortar.spotter then
            if Mortar.spotter == pl_obj then
                Mortar.unsetSpotter()
            end
        end

        if Mortar.bomber then
            if Mortar.bomber == pl_obj then
                Mortar.unsetBomber()
            end
        end



    end)
end

Mortar.unsetSpotter = function()
    Mortar.spotter = nil
end






---Check if the spotter has a working radio
---@param player any
Mortar.checkSpotterRadio = function(player)
    -- Pao: Binoculars shouldn't be necessary, only a radio. Binos are just an added bonus, imo
    -- Radios are set with Category = Item... So we have to fetch them before doing anything else
    local inv = player:getInventory()
    local items = inv:getItems()

    local radio
    for i = 0, items:size() - 1 do
        local item = items:get(i)
        local item_full_type = item:getFullType()

        -- not sure why instanceof didn't work, but this should be fine
        if luautils.stringStarts(item_full_type, "Radio.") then
            radio = item
            break
        end
    end

    -- Another problem, to check if a radio is turned on we need to get getDeviceData(), not isActivated
    if radio then
        local device_data = radio:getDeviceData()
        if device_data:getIsTurnedOn() then
            print("Mortar: Radio is ready to go for the spotter")
            return true
        end
    end
    return false
end


-------------------------------------------------------------
-- Various checks functions
------------------------------------------------------------

Mortar.isBomberValid = function(player)

    if player:isDriving() or player:getVehicle() then return false end
    if not player:isOutside() then return false end
    if player:HasTrait('HardOfHearing') or player:HasTrait('Deaf') then return false end
    if (player:isRunning() or player:isSprinting()) then return false end
    if not player:isAsleep() then return true end
    --TODO isHasFog --check if theres fog find the syntax  maybe  DayForecast() ? 

end


Mortar.isSpotterValid = function(player)
    if player:isDriving() or player:getVehicle() then return false end
    if player:HasTrait('ShortSighted')  then return false end
    --if pl:isAiming() or pl:isSneaking() then return false end
    if (player:isRunning() or player:isSprinting()) then return false end
    if not player:isAsleep() then return true end

end

-------------------------------------------------------------
-- Various functions
------------------------------------------------------------


-- Disassemble and returns the item to the player inventory
Mortar.disassemble = function()
    -- TODO Implement it?
end

-- Check the distance between bomber and mortar tile
Mortar.checkBomberDistanceFromMortar = function()


    if Mortar.bomber == nil then
        print("Mortar: Can't find bomber anymore, exiting update")
        Events.OnTick.Remove(Mortar.checkBomberDistanceFromMortar)
        MortarUI.close()        -- This also unset the bomber, kinda janky
        return
    end

    -- TODO We're not considering height, should be fine though.
    local pl_x = Mortar.bomber:getX()
    local pl_y = Mortar.bomber:getY()

    local mort_x = Mortar.current_mortar:getX()
    local mort_y = Mortar.current_mortar:getY()

    local max_distance_from_mortar = 1.5

    if MortarCommonFunctions.getDistance2D(pl_x, pl_y, mort_x, mort_y) > Mortar.distSteps then
        MortarUI.close()        -- This also unset the bomber, kinda janky
        Events.OnTick.Remove(Mortar.checkBomberDistanceFromMortar)

    end



end





-------------------------------------------------------
MortarInstance = nil

Mortar.instantiate = function()
    -- TODO Should be called whenever we spawn\set a new mortar, and destroyed whenever we remove it


    -- TODO Bomber, spotter, and coordinates should be sent to the instance, not the generic Mortar class
    if MortarInstance == nil then
        MortarInstance = {}
    end



end




local initMortarMod = function()
    print("Mortar Mod: Initializing")
    local pl = getPlayer()
    if not pl:getModData()['mortarDistance'] then
        pl:getModData()['mortarDistance'] = SandboxVars.Mortar.Radius or 8
    end
end
Events.OnGameStart.Add(initMortarMod)
